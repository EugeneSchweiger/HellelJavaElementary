import java.util.Scanner;
public class dummy {
    /*1.JRE-сборка из виртуальной машины и необходимых библиотек для запуска
    * приложений написаных на языке Java.JDK-ключает в себя JRE и дополняется
    * компилятором,дополнительными библиотеками для разработки и документацией
    * 2.JVM-Java Virtual Machine.Виртуальная машина Java.Берётся из JRE.Запускает
    * написаный разработчиком и скомпилированый код(байт-код) на той платформе,
    * на которую JVM написан.Нужен чтобы жрать производительность системы,ведь код
    * написаный на C или ассемблере работает гораздо быстрее,с другой стороны
    * позволяет запускать ранее написаный код на другой ОС.
    * 3.Особенностей много. Java медленная,т.к. есть "посредник" между кодом и железом.
    * Синтаксис очень похож на C#.Можно выбрать себе любую виртуальную машину.
    * Вообще байт коды такая интересная штука...Компьютер-просто железка,причем довольно
    * глупая,но в то же время-инструмент,так вот,чтобы заставить его что либо делать-
    * надо написать код.Чтобы код работал-его надо отправить в наш компьютер в читаемом
    * для НЕГО виде,собственно это и есть байт-код.
    * 4.Java-язык,потому что имеет 2 черты,присущие языку програмирования-грамматику и синтаксис
    * Платформа-потому что на нём разрабатывают приложения и сервисы для нескольких ОС с разной
    * конфигурацией железа.Собственно железо практически не важно,т.к. JVM исполнит байт-код
    * именно на нашем железе.
    * 5.И так и так. Сачала код компилируется(на выходе .class файл с байт-кодом),потом
    * интерпретируется по средством сил JVM с участием JIT
    * 6.JIT-Just in Time. Стероид для джавы,позволяющий преобразовывать байт-код в
    * машинный код на лету,во время работы программы. Жрёт память и процессорное время.
    * 7.Система сборки мусора. Она присутствует во многих языках. Применяется когда к объекту
    * не привязывается ни одна ссылка. Например:
    * int a=12\ a-объект класса int со значением 12 ,id=3654321(взято из головы)
    * int b= a\ b-объект класса int со ссылкой на объект а, id=3654321(тот же id что и а)
    * int a=42\ a-объект класса int со значением 42 ,id=3600001(объявили новый объект с именем а)
    * int b>>> 12\
    * id(b)>>>3654321\Вызов объекта "b". Почему 12 и id старого объекта "а"? Правильно,на объект
    *               "b" указывает ссылка на ранее созданный объект "а". Поэтому он в памяти всё еще
    *               существует.
    * int b=a
    * int b>>>42
    * id(b)>>>3600001\прировняли объект "b" к новому объекту "а". Теперь на ранее созданный "а" не указывает
    *                   ни одна ссылка. Его можно удалить из памяти.
    * Так и работает сборщик мусора.
    * */

    public static void main(String[] args){
        Scanner sc1 = new Scanner(System.in);
        System.out.println("Enter first digit");
        int a = sc1.nextInt();
        System.out.println("Enter second digit");
        int b = sc1.nextInt();
        sc1.close();
            String s ="Now some magic!";
            System.out.println(s);
        System.out.println("Sum of "+a+" and "+b+" is: "+(a+b));
        /*пытаясь бороться с проблемой версии компилятора(о чем я писал в скайпе) я прослушал момент с передачай
        * аргументов по индексам.Поэтому сделал первое задание как умею.*/

    }

}
